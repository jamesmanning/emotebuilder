{
  "name": "esniff",
  "version": "1.0.0",
  "description": "Low footprint ECMAScript source code parser",
  "author": {
    "name": "Mariusz Nowak",
    "email": "medyk@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "keywords": [
    "sniff",
    "analyze",
    "ast",
    "parse",
    "syntax",
    "sniffer",
    "detective",
    "detect",
    "find",
    "search",
    "source",
    "code"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/esniff.git"
  },
  "dependencies": {
    "d": "^0.1.1",
    "es5-ext": "^0.10.7"
  },
  "devDependencies": {
    "esprima": "^2.6",
    "tad": "^0.2.3",
    "xlint": "^0.2.2",
    "xlint-jslint-medikoo": "^0.1.4"
  },
  "scripts": {
    "lint": "node node_modules/xlint/bin/xlint --linter=node_modules/xlint-jslint-medikoo/index.js --no-cache --no-stream",
    "lint-console": "node node_modules/xlint/bin/xlint --linter=node_modules/xlint-jslint-medikoo/index.js --watch",
    "test": "node ./node_modules/tad/bin/tad"
  },
  "license": "MIT",
  "readme": "# esniff\n## Low footprint JavaScript source code parser\n\nLow footprint, fast source code parser, which allows you to find all code fragment occurrences with respect to all syntax rules that cannot be handled with plain regular expression search.\n\nIt aims at use cases where we need to quickly find usage of given function, property etc. in syntactically valid code.\n\n### Installation\n#### npm\n\n\t$ npm install esniff\n\nTo port it to Browser or any other (non CJS) environment, use your favorite CJS bundler. No favorite yet? Try: [Browserify](http://browserify.org/), [Webmake](https://github.com/medikoo/modules-webmake) or [Webpack](http://webpack.github.io/)\n\n### Usage\n\nUsing main module you can configure sophisticated parser on your own. However, first, __see preprared [API utilities](#API) that may already address use cases you have__.\n\n#### esniff(code, triggerChar, callback)\n\n* `code` Code to parse\n* `triggerChar` Character which is expected to trigger custom handling via `callback`\n* `callback` To detect and eventually handle case we're after\n\nExample: Find all `require(..)` calls:\n\n```javascript\nvar esniff = require('esniff');\n\nvar result = esniff('var x = require(\\'foo/bar\\')', 'r', function (index, previous, nest) {\n  if (previous === '.') return next(); // Ignore x.require calls\n  if (code.indexOf('require', index) !== index) return esniff.next(); // Not really `require` call\n  next('require'.length); // Move after `require` and skip any following whitespace\n  index = esniff.index; // Update index\n  if (code[i] !== '(') return resume(); // Not `require(`\n  return collectNest(); // Collect all code between parenthesis\n});\n\nconsole.log(result);  [{ point: 17, column: 17, line: 1, raw: '\\'foo/bar\\'' }]\n```\n\n#### API\n\n#### accessedProperties(objName) _(esniff/accessed-properties)_\n\nReturns function which allows us to find all accessed property names on given object name\n\n```javascript\nvar findProperties = require('esniff/accessed-properties');\nvar findContextProperties = findProperties('this');\n\nvar result = findContextProperties('var foo = \"0\"; this.bar = foo; this.someMethod(); otherFunction()');\nconsole.log(result); // [ { name: 'bar', start: 20, end: 23 }, { name: 'someMethod', start: 36, end: 46 } ]\n```\n\n#### function(name[, options]) _(esniff/function)_\n\nReturns function which allows us to find all occurrences of given function (or method) being invoked\n\nThrough options we can restrict cases which we're after:\n\n* `asProperty` (default: `false`), on true will allow `x.name()` when we search for `name` calls\n* `asPlain` (default: `true`), on true it allows plain calls e.g. `name()` when we search for `name`. Should be set to `false` if we're strictly about method calls.\n\nSetting both `asProperty` and `asPlain` to false, will always produce empty result\n\n```javascript\nvar findRequires = require('esniff/function')('require');\n\nfindRequires('var x = require(\\'foo/bar\\')');\n// [{ point: 17, column: 17, line: 1, raw: '\\'foo/bar\\'' }]\n```\n\n#### resolveArguments(code[, limit]) _(esniff/resolve-arguments)_\n\nResolves expressions separated with commas, with additional `limit` you can specify after which number of arguments resolver should stop\n\n```javascript\nvar resolveArgs = require('esniff/resolve-arguments');\n\nvar result = resolveArgs('\"raz\", \"dwa\", [\\'raz\\', \\'dwa\\'], \"trzy\"', 3));\n\nconsole.log(result); // ['\"raz\"', ' \"dwa\"', ' [\\'raz\\', \\'dwa\\']']\n```\n\n### Limitations\n\n* _esniff_ assumes code that you pass is syntactically correct, it won't inform you about any syntax errors and may produce unexpected and nonsense results when such code is used.\n* There's single case of syntactically correct code, which will make _esniff_ produce incorrect results, it's division made directly on object literal (e.g. `x = { foo: 'bar' } / 14`, esniff in that case will assume that `/` starts regular expression). Still there's not known use case where such code may make any sense, and many popular JS source code parsers share very same vulnerability.\n* _esniff_ may work with new syntax introduced by ECMAScript 6 but it has not been fully revised in that matter yet. Pull requests are welcome.\n\n## Tests [![Build Status](https://travis-ci.org/medikoo/esniff.svg)](https://travis-ci.org/medikoo/esniff)\n\n\t$ npm test\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/medikoo/esniff/issues"
  },
  "homepage": "https://github.com/medikoo/esniff#readme",
  "_id": "esniff@1.0.0",
  "_shasum": "a8d5b7d8fbe836b41b064e435b09c19988db142e",
  "_resolved": "https://registry.npmjs.org/esniff/-/esniff-1.0.0.tgz",
  "_from": "https://registry.npmjs.org/esniff/-/esniff-1.0.0.tgz"
}
