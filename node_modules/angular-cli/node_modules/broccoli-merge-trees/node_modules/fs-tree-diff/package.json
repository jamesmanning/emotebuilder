{
  "name": "fs-tree-diff",
  "version": "0.4.4",
  "description": "Backs out file tree changes",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha tests/",
    "test:debug": "mocha debug tests/"
  },
  "keywords": [
    "broccoli"
  ],
  "author": {
    "name": "Stefan Penner, David J. Hamilton, Chad Hietala"
  },
  "license": "MIT",
  "dependencies": {
    "debug": "^2.2.0",
    "fast-ordered-set": "^1.0.2"
  },
  "devDependencies": {
    "chai": "^3.3.0",
    "mocha": "^2.3.3"
  },
  "readme": "# fs-tree-diff [![Build Status](https://travis-ci.org/stefanpenner/fs-tree-diff.svg)](https://travis-ci.org/stefanpenner/fs-tree-diff)\n\nFSTree provides the means to calculate a patch (set of operations) between one file system tree and another.\n\nThe possible operations are:\n\n* `unlink` – remove the specified file\n* `rmdir` – remove the specified folder\n* `unlinkdir` - remove the specified folder symlink\n* `mkdir` – create the specified folder\n* `linkdir` - symlink the specified folder\n* `create` – create the specified file\n* `change` – update the specified file to reflect changes\n\nThe operations choosen aim to minimize the amount of IO required to apply a given patch.\nFor example, a naive `rm -rf` of a directory tree is actually quite costly, as child directories\nmust be recursively traversed, entries stated.. etc, all to figure out what first must be deleted.\nSince we patch from tree to tree, discovering new files is both wasteful and un-needed.\n\nThe operations will also be provided in the correct order. So when deleting a large tree, unlink\nand rmdir operations will be provided depthFirst. Allowing us to safely replay the operations without having to first confirm the FS is as we expected.\n\nA simple example:\n\n```js\nvar FSTree = require('fs-tree-diff');\nvar current = FSTree.fromPaths([\n  'a.js'\n]);\n\nvar next = FSTree.fromPaths({\n  'b.js'\n});\n\ncurrent.calculatePatch(next) === [\n  ['unlink', 'a.js'],\n  ['create', 'b.js']\n];\n```\n\nA slightly more complicated example:\n\n```js\nvar FSTree = require('fs-tree-diff');\nvar current = FSTree.fromPaths([\n  'a.js',\n  'b/f.js'\n]);\n\nvar next = FSTree.fromPaths({\n  'b.js',\n  'b/c/d.js'\n  'b/e.js'\n});\n\ncurrent.calculatePatch(next) === [\n  ['unlink', 'a.js'],\n  ['unlink', 'b/f.js'],\n  ['create', 'b.js'],\n  ['mkdir', 'b/c'],\n  ['create', 'b/c/d.js'],\n  ['create', 'b/e.js']\n];\n```\n\nNow, the above examples do not demonstrate `update` operations. This is because when providing only paths, we do not have sufficient information to check if one entry is merely different from another with the same relativePath.\n\nFor this, FSTree supports more complex input structure. To demonstrate, We will use the [walk-sync](https://github.com/joliss/node-walk-sync) module. Which provides higher fidelity input, allowing FSTree to also detect changes. More on what an [entry from walkSync.entries is](https://github.com/joliss/node-walk-sync#entries)\n\n```js\nvar walkSync = require('walk-sync');\n\n// path/to/root/foo.js\n// path/to/root/bar.js\nvar current = new FSTree({\n  entries: walkSync.entries('path/to/root')\n});\n\nwriteFileSync('path/to/root/foo.js', 'new content');\nwriteFileSync('path/to/root/baz.js', 'new file');\n\nvar next = new FSTree({\n  entries: walkSync.entries('path/to/root')\n});\n\ncurrent.calculatePatch(next) === [\n  ['update', 'foo.js'], // mtime + size changed, so this input is stale and needs updating.\n  ['create', 'baz.js']  // new file, so we should create it\n  /* bar stays the same and is left inert*/\n];\n\n```\n",
  "readmeFilename": "README.md",
  "_id": "fs-tree-diff@0.4.4",
  "_shasum": "f6b75d70db22c1f3b05d592270f4ed6c9c2f82dd",
  "_resolved": "https://registry.npmjs.org/fs-tree-diff/-/fs-tree-diff-0.4.4.tgz",
  "_from": "https://registry.npmjs.org/fs-tree-diff/-/fs-tree-diff-0.4.4.tgz"
}
